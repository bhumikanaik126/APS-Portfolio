

## Relevance Ranking using Longest Common Subsequence (LCS)

üîç *Matching user query with document titles or content using dynamic programming*

---

### ‚úÖ Problem Statement

When a user searches for something like **"apple ios update"**, the search engine must determine which documents are **most relevant**, even if the words appear in a **different order or partially**.

We need a scoring method that rewards documents with **similar word sequences** ‚Äî even if not exact.

---

### üß† Why LCS?

- **LCS (Longest Common Subsequence)** finds the longest sequence that appears **in order** in both strings, but not necessarily **contiguously**.
- Ideal for:
  - Query vs. Document Title
  - Query vs. Snippet
- It allows partial matches, while still **preserving the order** of the original query, which is crucial for semantic meaning.

---

### üß™ Real Google Use Case

For every indexed document:

- Extract its **title** and/or **snippet**
- Calculate **LCS score** with the user query
- Use this as a **feature** in the ranking algorithm

---

### üîç Example: LCS Scoring in Action

| User Query        | Document Title            | LCS                 | Score (LCS length / Query length) |
|-------------------|---------------------------|---------------------|-----------------------------------|
| "apple ios update" | "latest ios apple news"    | "apple ios"         | 2 / 3 ‚âà 0.67                     |
| "apple ios update" | "apple update for ios"     | "apple ios update"  | 3 / 3 = 1.0                     |

‚úÖ The second title ranks **higher** because it preserves both the **order** and **completeness** of the query terms.

---

### üõ†Ô∏è C++ Code: LCS Scoring

[View code here](https://github.com/bhumikanaik126/APS-Portfolio/blob/main/codes/b1.cpp){:target="_blank"}<br><br><br>


