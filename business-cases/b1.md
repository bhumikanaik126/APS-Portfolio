

## Relevance Ranking using Longest Common Subsequence (LCS)

üîç *Matching user query with document titles or content using dynamic programming*

---

### ‚úÖ Problem Statement

When a user searches for something like **"apple ios update"**, the search engine must determine which documents are **most relevant**, even if the words appear in a **different order or partially**.

We need a scoring method that rewards documents with **similar word sequences** ‚Äî even if not exact.

---

### üß† Why LCS?

- **LCS (Longest Common Subsequence)** finds the longest sequence that appears **in order** in both strings, but not necessarily **contiguously**.
- Ideal for:
  - Query vs. Document Title
  - Query vs. Snippet
- It allows partial matches, while still **preserving the order** of the original query, which is crucial for semantic meaning.

---

### üß™ Real Google Use Case

For every indexed document:

- Extract its **title** and/or **snippet**
- Calculate **LCS score** with the user query
- Use this as a **feature** in the ranking algorithm

---

### üîç Example: LCS Scoring in Action

| User Query        | Document Title            | LCS                 | Score (LCS length / Query length) |
|-------------------|---------------------------|---------------------|-----------------------------------|
| "apple ios update" | "latest ios apple news"    | "apple ios"         | 2 / 3 ‚âà 0.67                     |
| "apple ios update" | "apple update for ios"     | "apple ios update"  | 3 / 3 = 1.0                     |

‚úÖ The second title ranks **higher** because it preserves both the **order** and **completeness** of the query terms.

---

### üõ†Ô∏è C++ Code: LCS Scoring

{% raw %}
```cpp
#include <iostream>
#include <vector>
#include <string>
using namespace std;

// Function to compute LCS length
int LCS(string a, string b) {
    int m = a.length(), n = b.length();
    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));

    // Build the LCS table
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (a[i - 1] == b[j - 1])
                dp[i][j] = 1 + dp[i - 1][j - 1];
            else
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
        }
    }

    return dp[m][n];
}
double computeSimilarity(string query, string title) {
    int lcsLen = LCS(query, title);
    return (double)lcsLen / query.length(); // Can also use avg length
}
